#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Simulate alignments with varying degrees of pairwise epistasis
"""
import numpy as np
import os
import sconsutils
from SCons.Script import Environment, AddOption, GetOption, File
from nestly import Nest
from nestly.scons import SConsWrap

sconsutils

# Set up SCons environment
environ = os.environ.copy()
env = Environment(ENV=environ)

# command line arguments
AddOption('--revpath',
          type='str',
          metavar='<PATH>',
          help='path to RevBayes if not in $PATH (default "rb")',
          default='rb')
revpath = GetOption('revpath')

AddOption('--replicates',
          type='int',
          metavar='<N>',
          help='N replicates in each grid cell (default 1)',
          default=1)
replicates = GetOption('replicates')

AddOption('--output',
          type='str',
          metavar='<PATH>',
          help='output directory path (default "scons_output")',
          default='scons_output')
output = GetOption('output')

nest = SConsWrap(Nest(), output, alias_environment=env)

# check that RevBayes path is valid by attempting to access its help
rb_check = Command(f'{output}/scons.log',
                   None,
                   f'{revpath} -h > $TARGET')

# aggregators perform analysis on a nest
# this one will collect the mutual information matrices
nest.add_aggregate('mi_agg', list)
nest.add_aggregate('G93_agg', list)

# nests define parameter sweeps
nest.add('d', (.5, 2, 8))
nest.add('n_iid', range(4, 404, 4))
n_epi_range = np.array(range(4, 404, 4))
if any(n_epi_range % 2 != 0):
    raise ValueError('n_epi must be even!')
nest.add('n_epi', n_epi_range)
nest.add('replicate', range(1, replicates + 1))

# a random seed for each grid cell will be needed for rev
seed_dict = {(cell[1]['d'], cell[1]['n_iid'], cell[1]['n_epi'],
              cell[1]['replicate']): seed for seed, cell in enumerate(nest, 1)}


@nest.add_target()
def revscript(outdir, c):
    '''make RevBayes script from template'''
    seed = seed_dict[(c["d"], c["n_iid"], c["n_epi"], c["replicate"])]
    return env.Command(f'{outdir}/sim_aln.Rev',
                       None,
                       'Rscript simulation_scripts/mk_alns_revscript.R '
                       f'{c["n_iid"]} {c["n_epi"]} {c["d"]} {seed} '
                       f'{outdir} {revpath} > {outdir}/mk_alns_revscript.log')


@nest.add_target()
def alns(outdir, c):
    '''iid and epistatic alignments'''
    return env.SRun([f'{outdir}/iid_aln.nex',
                     f'{outdir}/epi_aln.nex'],
                    c['revscript'],
                    f'{revpath} $SOURCE > {outdir}/revscript.log')
    env.Depends(alns, rb_check)
    return alns


@nest.add_target()
def aln(outdir, c):
    '''concatentate the iid and epistatic alignments into one'''
    return env.Command(f'{outdir}/aln.nex',
                       c['alns'],
                       'Rscript simulation_scripts/merge_alns.R '
                       '$SOURCES $TARGET '
                       f' > {outdir}/merge_alns.log')


@nest.add_target()
def trees(outdir, c):
    '''MCMC tree inference'''
    return env.SRun([f'{outdir}/analysis.Rev', f'{outdir}/analysis_run_1.trees',
                     f'{outdir}/analysis_run_2.trees', f'{outdir}/run_Rev.log'],
                    c['aln'],
                    f'Rscript analysis_scripts/run_Rev.R {c["replicate"]} '
                    f'$SOURCE {revpath} > ${{TARGETS[3]}}')


@nest.add_target()
def convergence(outdir, c):
    '''convergence checks'''
    return env.SRun([f'{outdir}/diagnose_convergence.tsv',
                     f'{outdir}/diagnose_convergence.log'],
                    c['trees'],
                    f'Rscript analysis_scripts/diagnose_convergence.R '
                    f'${{SOURCES[1]}} ${{SOURCES[2]}} 1> ${{TARGETS[0]}}'
                    f' 2> ${{TARGETS[1]}}')


@nest.add_target()
def mi(outdir, c):
    '''column mutual information matrix summary stats'''
    mi = env.SRun(f'{outdir}/aln.nex.mi.summary.tsv',
                  c['aln'],
                  'python indices/align_mi.py $SOURCES')
    c['mi_agg'].append({'d': c['d'], 'n_iid': c['n_iid'], 'n_epi': c['n_epi'],
                        'tgt': mi})
    return mi


@nest.add_target()
def G93(outdir, c):
    '''multinomial likelihood summary stat from Goldman (1993)'''
    G93 = env.SRun(f'{outdir}/aln.nex.G93.summary.tsv',
                    c['aln'],
                    'Rscript indices/goldman_yang_1993.R $SOURCE $TARGET')
    c['G93_agg'].append({'d': c['d'], 'n_iid': c['n_iid'],
                         'n_epi': c['n_epi'], 'tgt': G93})
    return G93


# pop to the top level to aggregate
nest.pop('d')


@nest.add_target()
def mi_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of mi paths w/ associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['mi_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    mi_input = env.Textfile(f'{outdir}/mi_agg.input.tsv', lines)
    env.Depends(mi_input, Flatten(mi['tgt']))
    return mi_input


@nest.add_target()
def G93_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of G93 paths w/ associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['G93_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    G93_input = env.Textfile(f'{outdir}/G93_agg.input.tsv', lines)
    env.Depends(G93_input, Flatten(mi['tgt']))
    return G93_input


@nest.add_target()
def mi_agg(outdir, c):
    '''aggregate mutual infomation matrices'''
    mi_agg = env.SRun(f'{outdir}/agg_skewness.pdf',
                      c['mi_agg_input'],
                      f'python utils/stats_agg.py $SOURCE {outdir}')
    env.Depends(mi_agg, [x['tgt'] for x in c['mi_agg']])
    return mi_agg


@nest.add_target()
def G93_agg(outdir, c):
    '''aggregate Goldman (1993) multinomial likelihood matrices'''
    G93_agg = env.SRun(f'{outdir}/agg_G93.pdf',
                       c['G93_agg_input'],
                       f'python utils/stats_agg.py $SOURCE {outdir}')
    env.Depends(G93_agg, [x['tgt'] for x in c['G93_agg']])
    return G93_agg
