#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Simulate alignments with varying degrees of pairwise epistasis
"""
import numpy as np
import os
import sconsutils
from SCons.Script import Environment, AddOption, GetOption
from nestly import Nest
from nestly.scons import SConsWrap

sconsutils

# Set up SCons environment
environ = os.environ.copy()
env = Environment(ENV=environ)

# command line arguments
AddOption('--revpath',
          type='str',
          metavar='<PATH>',
          help='path to RevBayes if not in $PATH (default "rb")',
          default='rb')
revpath = GetOption('revpath')

AddOption('--replicates',
          type='int',
          metavar='<N>',
          help='N replicates in each grid cell (default 1)',
          default=1)
replicates = GetOption('replicates')

AddOption('--output',
          type='str',
          metavar='<PATH>',
          help='output directory path (default "scons_output")',
          default='scons_output')
output = GetOption('output')

AddOption('--slurm',
          action='store_true',
          help='submit commands to slurm cluster (default False)')
if GetOption('slurm'):
    Command = env.SRun
else:
    Command = env.Command

nest = SConsWrap(Nest(), output, alias_environment=env)

# check that RevBayes path is valid by attempting to access its help
rb_check = Command(f'{output}/scons.log',
                   None,
                   f'{revpath} -h > $TARGET')

# aggregators perform analysis on a nest
# this one will collect the mutual information matrices
nest.add_aggregate('mi_agg', list)

# nests define parameter sweeps
nest.add('d', (1, 10))
nest.add('n_iid', range(10, 110, 10))
n_epi_range = np.array(range(10, 110, 10))
if any(n_epi_range % 2 != 0):
    raise ValueError('n_epi must be even!')
nest.add('n_epi', n_epi_range)
nest.add('replicate', range(1, replicates + 1))


@nest.add_target()
def alns(outdir, c):
    '''iid and epistatic alignments'''
    alns = Command([f'{outdir}/iid_aln.nex',
                    f'{outdir}/epi_aln.nex'],
                   None,
                   'Rscript simulation_scripts/mk_alns.R '
                   f'{c["n_iid"]} {c["n_epi"]} {c["d"]} {c["replicate"]} '
                   f'{outdir} {revpath} &> {outdir}/mk_alns.log')
    env.Depends(alns, rb_check)
    return alns


@nest.add_target()
def aln(outdir, c):
    '''concatentate the iid and epistatic alignments into one'''
    return Command(f'{outdir}/aln.nex',
                   c['alns'],
                   'Rscript simulation_scripts/merge_alns.R '
                   '$SOURCES $TARGET '
                   f' &> {outdir}/merge_alns.log')


@nest.add_target()
def trees(outdir, c):
    '''MCMC tree inference'''
    return Command([f'{outdir}/analysis.Rev', f'{outdir}/analysis_run_1.trees',
                    f'{outdir}/analysis_run_2.trees', f'{outdir}/run_Rev.log'],
                   c['aln'],
                   f'Rscript analysis_scripts/run_Rev.R {c["replicate"]} '
                   f'$SOURCE {revpath} > ${{TARGETS[3]}}')


@nest.add_target()
def convergence(outdir, c):
    '''convergence checks'''
    return Command(f'{outdir}/diagnose_convergence.log',
                   c['trees'],
                   f'Rscript analysis_scripts/diagnose_convergence.R '
                   f'${{SOURCES[1]}} ${{SOURCES[2]}} > $TARGET')


@nest.add_target()
def mi(outdir, c):
    '''column mutual information matrix summary stats'''
    mi = Command(f'{outdir}/aln.nex.mi.summary.tsv',
                 c['aln'],
                 'python indices/align_mi.py $SOURCES')
    c['mi_agg'].append({'d': c['d'], 'n_iid': c['n_iid'], 'n_epi': c['n_epi'],
                        'tgt': mi})
    return mi


# pop to the top level to aggregate
nest.pop('d')


@nest.add_target()
def mi_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of mi paths with associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['mi_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    mi_input = env.Textfile(f'{outdir}/mi_agg.input.tsv', lines)
    # env.Depends(mi_input, Flatten(mi['tgt']))
    return mi_input


@nest.add_target()
def mi_agg(outdir, c):
    '''aggregate mutual infomation matrices'''
    return Command(f'{outdir}/mi_agg.skewness.pdf',
                   c['mi_agg_input'],
                   f'python utils/mi_agg.py $SOURCE {outdir}')
