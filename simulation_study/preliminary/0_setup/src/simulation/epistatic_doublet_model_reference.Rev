## The epistatic doublet model of Nasrallah and Huelsenbeck (2013)
# This is the model setup as a graphical model with all nodes as variables
# This is a reference, when simulating from the model we will avoid drawing most values in favor of manual specification

## The model
# States from 1:16 are
#  AA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT

# The underlying GTR model exchange rates
er ~ dnDirichlet(v(1,1,1,1,1,1))

# Put the rates in a matrix for ease of accessing them to put them in the codon rate matrix
S := fnFreeSymmetricRateMatrix(er,rescaled=false)

# Stationary frequencies of the doublets
df ~ dnDirichlet(rep(1,16))

# Term for epistatic interactions
epistasis_d ~ dnHalfCauchy(0,1)

# To help us navigate making the Q matrix
d1 <- v(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)
d2 <- v(1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4)

# Assemble an unscaled rate matrix
for (i in 1:16) {
  # x_1 and x_2 help us tell what cell in the GTR model we'd be in
  # Namely, they tell us the first nucleotide and second nucleotide in the "from" doublet under consideration
  x_1 = d1[i]
  x_2 = d2[i]

  for (j in 1:16) {
    # y_1 and y_2 tell us the same thing for the "to" doublet
    y_1 = d1[j]
    y_2 = d2[j]

    if (i == j) { # Catch diagonal entries first, this allows us to not add exceptions to our cases in next if statements
      unscaled_Q[i][j] = 0
    } else if ( (x_1 == 1 && x_2 == 4 || x_1 == 4 && x_2 == 1 || x_1 == 2 && x_2 == 3 || x_1 == 3 && x_2 == 2) && (y_1 == 1 && y_2 == 4 || y_1 == 4 && y_2 == 1 || y_1 == 2 && y_2 == 3 || y_1 == 3 && y_2 == 2) ) {  # Change from one canonically paired doublet to another
      unscaled_Q[i][j] := epistasis_d * S[x_1][y_1] * S[x_2][y_2] * df[j]
    } else if (x_2 == y_2) { # single base change at first base, second base is the same
      unscaled_Q[i][j] := S[x_1][y_1] * df[j]
    } else if (x_1 == y_1) { # single base change at second base, first base is the same
      unscaled_Q[i][j] := S[x_2][y_2] * df[j]
    } else { # double mutation of a disallowed variety
      unscaled_Q[i][j] = 0
    }
  }
}

Q := fnFreeK(unscaled_Q, scale=true)

q()
