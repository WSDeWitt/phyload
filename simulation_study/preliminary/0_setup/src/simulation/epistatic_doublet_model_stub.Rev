## The epistatic doublet model of Nasrallah and Huelsenbeck (2013)
# This is a stub script, designed to be called from a higher level script that defines most simulating parameters
# States from 1:16 are
#  AA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT

# Put the underlying GTR model exchange rates in a matrix for ease of accessing them to put them in the codon rate matrix
S := fnFreeSymmetricRateMatrix(er,rescaled=false)

# Stationary frequencies of the doublets
# We draw from a Dirchlet(alpha=2) instead of the Dirchlet(alpha=1) originally used to make frequencies somewhat more even
df ~ dnDirichlet(rep(2,16))

# To help us navigate making the Q matrix
d1 <- v(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)
d2 <- v(1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4)

# Assemble an unscaled rate matrix
for (i in 1:16) {
  # x_1 and x_2 help us tell what cell in the GTR model we'd be in
  # Namely, they tell us the first nucleotide and second nucleotide in the "from" doublet under consideration
  x_1 = d1[i]
  x_2 = d2[i]

  for (j in 1:16) {
    # y_1 and y_2 tell us the same thing for the "to" doublet
    y_1 = d1[j]
    y_2 = d2[j]

    if (i == j) { # Catch diagonal entries first, this allows us to not add exceptions to our cases in next if statements
      unscaled_Q[i][j] = 0
    } else if ( (x_1 == 1 && x_2 == 4 || x_1 == 4 && x_2 == 1 || x_1 == 2 && x_2 == 3 || x_1 == 3 && x_2 == 2) && (y_1 == 1 && y_2 == 4 || y_1 == 4 && y_2 == 1 || y_1 == 2 && y_2 == 3 || y_1 == 3 && y_2 == 2) ) {  # Change from one canonically paired doublet to another
      unscaled_Q[i][j] := abs(epistasis_d * S[x_1][y_1] * S[x_2][y_2] * df[j])
    } else if (x_2 == y_2) { # single base change at first base, second base is the same
      unscaled_Q[i][j] := abs(S[x_1][y_1] * df[j])
    } else if (x_1 == y_1) { # single base change at second base, first base is the same
      unscaled_Q[i][j] := abs(S[x_2][y_2] * df[j])
    } else { # double mutation of a disallowed variety
      unscaled_Q[i][j] = 0
    }
  }
}

Q_epi := fnFreeK(unscaled_Q, rescaled=true,matrixExponentialMethod="scalingAndSquaring")
