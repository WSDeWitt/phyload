#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Simulate alignments with varying degrees of pairwise epistasis
"""
import numpy as np
import os
import sconsutils
from SCons.Script import Environment, AddOption, GetOption

sconsutils

# Set up SCons environment
environ = os.environ.copy()
env = Environment(ENV=environ)

# command line arguments
AddOption('--revpath',
          type='str',
          metavar='<PATH>',
          help='path to RevBayes if not in $PATH (default "rb")',
          default='rb')
revpath = GetOption('revpath')

AddOption('--replicates',
          type='int',
          metavar='<N>',
          help='N replicates in each grid cell (default 1)',
          default=1)
replicates = GetOption('replicates')

AddOption('--output',
          type='str',
          metavar='<PATH>',
          help='output directory path (default "scons_output")',
          default='scons_output')
output = GetOption('output')

AddOption('--slurm',
          action='store_true',
          help='submit commands to slurm cluster (default False)')
if GetOption('slurm'):
    Command = env.SRun
else:
    Command = env.Command

# check that RevBayes path is valid by attempting to access its help
rb_check = Command(f'{output}/scons.log',
                   None,
                   f'{revpath} -h > $TARGET')

# aggregate mutual information matrix targets
mi_agg = []

# parameter sweep
for d in (1, 10):
    for n_iid in range(10, 30, 10):
        for n_epi in range(10, 30, 10):
            for replicate in range(1, replicates + 1):
                if n_epi % 2 != 0:
                    raise ValueError('n_epi must be even!')
                outdir = f'{output}/d{d}/n_iid{n_iid}/n_epi{n_epi}/rep{replicate}'
                # iid and epistatic alignments
                alns = Command([f'{outdir}/iid_aln.nex',
                                f'{outdir}/epi_aln.nex'],
                               None,
                               'Rscript simulation_scripts/mk_alns.R '
                               f'{n_iid} {n_epi} {d} {replicate} '
                               f'{outdir} {revpath} &> {outdir}/mk_alns.log')
                env.Depends(alns, rb_check)
                # concatentate the iid and epistatic alignments into one
                aln = Command(f'{outdir}/aln.nex',
                               alns,
                               'Rscript simulation_scripts/merge_alns.R '
                               '$SOURCES $TARGET '
                               f' &> {outdir}/merge_alns.log')
                # column mutual information matrix summary stats
                mi = Command(f'{outdir}/aln.nex.mi.summary.tsv',
                             aln,
                             'python indices/align_mi.py $SOURCES')
                mi_agg.append({'d': d, 'n_iid': n_iid, 'n_epi': n_epi,
                                    'tgt': mi})

# some scons ninjutsu for building a file of mi paths with associated args
# first the header line
cmds = ['echo \'d\\tn_iid\\tn_epi\\tpath\' > $TARGET']
sources = []
for i, mi in enumerate(mi_agg):
    sources.append(mi['tgt'])
    cmds.append(f'echo \'{mi["d"]}\\t{mi["n_iid"]}\\t{mi["n_epi"]}\\t${{SOURCES[{i}]}}\' >> $TARGET')
cmd = ' && '.join(cmds)
mi_agg_input = Command(f'{output}/mi_agg.input.tsv', sources, cmd)

# aggregate mutual infomation matrices
Command(f'{output}/mi_agg.skewness.pdf',
               mi_agg_input,
               f'python utils/mi_agg.py $SOURCE {output}')
