#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Simulate alignments with varying degrees of pairwise epistasis
"""
import numpy as np
import os
import sconsutils
from SCons.Script import Environment, AddOption, GetOption, File, Command, \
                         Flatten
from nestly import Nest
from nestly.scons import SConsWrap

sconsutils

# Set up SCons environment
environ = os.environ.copy()
env = Environment(ENV=environ)

# command line arguments

AddOption('--treepath',
          type='str',
          metavar='<PATH>',
          help='path to tree used for simulation')
treepath = GetOption('treepath')

AddOption('--revpath',
          type='str',
          metavar='<PATH>',
          help='path to RevBayes if not in $PATH (default "rb")',
          default='rb')
revpath = GetOption('revpath')

AddOption('--replicates',
          type='int',
          metavar='<N>',
          help='N replicates in each grid cell (default 1)',
          default=1)
replicates = GetOption('replicates')

AddOption('--output',
          type='str',
          metavar='<PATH>',
          help='output directory path (default "scons_output")',
          default='scons_output')
output = GetOption('output')

nest = SConsWrap(Nest(), output, alias_environment=env)

# check that RevBayes path is valid by attempting to access its help
rb_check = Command(f'{output}/scons.log',
                   None,
                   f'{revpath} -h > $TARGET')

# aggregators perform analysis on a nest
# these will collect the summary stat matrices
nest.add_aggregate('mi_agg', list)
nest.add_aggregate('G93_agg', list)
nest.add_aggregate('pv_agg', list)
nest.add_aggregate('st_agg', list)

# nests define parameter sweeps
nest.add('d', (.5, 2, 8))
nest.add('n_iid', range(4, 12, 4))
n_epi_range = np.array(range(4, 12, 4))
if any(n_epi_range % 2 != 0):
    raise ValueError('n_epi must be even!')
nest.add('n_epi', n_epi_range)
nest.add('replicate', range(1, replicates + 1))

# a random seed for each grid cell will be needed for rev
seed_dict = {(cell[1]['d'], cell[1]['n_iid'], cell[1]['n_epi'],
              cell[1]['replicate']): seed for seed, cell in enumerate(nest, 1)}

@nest.add_target()
def alns(outdir, c):
    '''iid and epistatic alignments'''
    seed = seed_dict[(c["d"], c["n_iid"], c["n_epi"], c["replicate"])]
    return env.SRun([f'{outdir}/iid_aln.nex',
                     f'{outdir}/epi_aln.nex'],
                    None,
                    f'{revpath} simulation_scripts/simulate_alns.Rev --args '
                    f'{c["n_iid"]} {c["n_epi"]} {c["d"]} {seed} {outdir} {treepath}'
                    ' > {outdir}/alns.log')
    env.Depends(alns, rb_check)
    return alns


@nest.add_target()
def aln(outdir, c):
    '''concatentate the iid and epistatic alignments into one'''
    return env.Command(f'{outdir}/aln.nex',
                       c['alns'],
                       'Rscript simulation_scripts/merge_alns.R '
                       '$SOURCES $TARGET '
                       f' > {outdir}/merge_alns.log')

@nest.add_target()
def trees(outdir, c):
    '''MCMC tree inference'''
    seed = seed_dict[(c["d"], c["n_iid"], c["n_epi"], c["replicate"])]
    return env.SRun([f'{outdir}/stochastic_variables_run_1.log',
                     f'{outdir}/stochastic_variables_run_2.log'],
                    c['aln'],
                    f'{revpath} analysis_scripts/run_analysis.Rev --args '
                    f'{seed} $SOURCES {outdir}'
                    '> {outdir}/trees.log')

# calc summary stats
@nest.add_target()
def convergence(outdir, c):
    '''convergence checks'''
    return env.SRun([f'{outdir}/diagnose_convergence.tsv',
                     f'{outdir}/diagnose_convergence.log'],
                    c['trees'],
                    f'Rscript analysis_scripts/diagnose_convergence.R '
                    '$SOURCES 1> ${TARGETS[0]}'
                    ' 2> ${TARGETS[1]}')


@nest.add_target()
def mi(outdir, c):
    '''column mutual information matrix summary stats'''
    mi = env.SRun(f'{outdir}/aln.nex.mi.summary.tsv',
                  c['aln'],
                  'python indices/align_mi.py $SOURCES')
    c['mi_agg'].append({'d': c['d'], 'n_iid': c['n_iid'], 'n_epi': c['n_epi'],
                        'tgt': mi})
    return mi


@nest.add_target()
def G93(outdir, c):
    '''multinomial likelihood summary stat from Goldman (1993)'''
    G93 = env.SRun(f'{outdir}/aln.nex.G93.summary.tsv',
                   c['aln'],
                   'Rscript indices/goldman_yang_1993.R $SOURCE $TARGET')
    c['G93_agg'].append({'d': c['d'], 'n_iid': c['n_iid'],
                         'n_epi': c['n_epi'], 'tgt': G93})
    return G93


@nest.add_target()
def pv(outdir, c):
    '''pairwise variance summary stat'''
    pv = env.SRun(f'{outdir}/aln.nex.PV.summary.tsv',
                  c['aln'],
                  'Rscript indices/pairwise_variance.R $SOURCE $TARGET')
    c['pv_agg'].append({'d': c['d'], 'n_iid': c['n_iid'],
                        'n_epi': c['n_epi'], 'tgt': pv})
    return pv


@nest.add_target()
def st(outdir, c):
    '''singleton fixed tree summary stat'''
    st = env.SRun(f'{outdir}/aln.nex.ST.summary.tsv',
<<<<<<< HEAD
<<<<<<< HEAD
                  [c['aln'], treepath],
=======
                  [c['aln'], 'simulation_scripts/simulation_tree.tre'],
>>>>>>> added in pairwise variance and singleton tree summary stats
=======
                  [c['aln'], treepath],
>>>>>>> added tree path as a global variable
                  'Rscript indices/singleton_fixed_tree.R $SOURCES $TARGET')
    c['st_agg'].append({'d': c['d'], 'n_iid': c['n_iid'],
                        'n_epi': c['n_epi'], 'tgt': st})
    return st


# pop to the top level to aggregate
nest.pop('d')


# create input tsv with file paths
@nest.add_target()
def mi_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of mi paths w/ associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['mi_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    mi_input = env.Textfile(f'{outdir}/mi_agg.input.tsv', lines)
    env.Depends(mi_input, Flatten(mi['tgt']))
    return mi_input


@nest.add_target()
def G93_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of G93 paths w/ associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['G93_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    G93_input = env.Textfile(f'{outdir}/G93_agg.input.tsv', lines)
    env.Depends(G93_input, Flatten(mi['tgt']))
    return G93_input


@nest.add_target()
def pv_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of pv paths w/ associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['pv_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    pv_input = env.Textfile(f'{outdir}/PV_agg.input.tsv', lines)
    env.Depends(pv_input, Flatten(mi['tgt']))
    return pv_input


@nest.add_target()
def st_agg_input(outdir, c):
    '''some scons ninjutsu for building a file of st paths w/ associated args
    '''
    # first the header line
    lines = ['d\tn_iid\tn_epi\tpath']
    for mi in c['st_agg']:
        lines.append(f"{mi['d']}\t{mi['n_iid']}\t{mi['n_epi']}"
                     f"\t{File(mi['tgt'][0])}")
    st_input = env.Textfile(f'{outdir}/ST_agg.input.tsv', lines)
    env.Depends(st_input, Flatten(mi['tgt']))
    return st_input


# aggregate stats
@nest.add_target()
def mi_agg(outdir, c):
    '''aggregate mutual infomation matrices'''
    mi_agg = env.SRun(f'{outdir}/agg_skewness.pdf',
                      c['mi_agg_input'],
                      f'python utils/stats_agg.py $SOURCE {outdir}')
    env.Depends(mi_agg, [x['tgt'] for x in c['mi_agg']])
    return mi_agg


@nest.add_target()
def G93_agg(outdir, c):
    '''aggregate Goldman (1993) multinomial likelihood matrices'''
    G93_agg = env.SRun(f'{outdir}/agg_G93.pdf',
                       c['G93_agg_input'],
                       f'python utils/stats_agg.py $SOURCE {outdir}')
    env.Depends(G93_agg, [x['tgt'] for x in c['G93_agg']])
    return G93_agg


@nest.add_target()
def pv_agg(outdir, c):
    '''aggregate pairwise variance matrices'''
    pv_agg = env.SRun(f'{outdir}/agg_PV.pdf',
                      c['pv_agg_input'],
                      f'python utils/stats_agg.py $SOURCE {outdir}')
    env.Depends(pv_agg, [x['tgt'] for x in c['pv_agg']])
    return pv_agg


@nest.add_target()
def st_agg(outdir, c):
    '''aggregate singleton fixed tree matrices'''
    st_agg = env.SRun(f'{outdir}/agg_ST.pdf',
                      c['st_agg_input'],
                      f'python utils/stats_agg.py $SOURCE {outdir}')
    env.Depends(st_agg, [x['tgt'] for x in c['st_agg']])
    return st_agg
