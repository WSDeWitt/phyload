#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Simulate alignments with varying degrees of pairwise epistasis
"""
import numpy as np
import os
# import sconsutils
from SCons.Script import Environment, AddOption, GetOption
from nestly import Nest
from nestly.scons import SConsWrap

# sconsutils
# ^ see this dir in gctree for slurm job submission utils

# Set up SCons environment
environ = os.environ.copy()
env = Environment(ENV=environ)

# command line arguments
AddOption('--revpath',
          dest='revpath',
          type='str',
          metavar='<PATH>',
          help='path to RevBayes if not in $PATH (default "rb")',
          default='rb')
revpath = GetOption('revpath')

AddOption('--replicates',
          dest='replicates',
          type='int',
          metavar='<N>',
          help='N replicates in each grid cell (default 1)',
          default=1)
replicates = GetOption('replicates')

AddOption('--output',
          dest='output',
          type='str',
          metavar='<PATH>',
          help='output directory path (default "scons_output")',
          default='scons_output')
output = GetOption('output')

nest = SConsWrap(Nest(), output, alias_environment=env)

# check that RevBayes path is valid by attempting to access its help
rb_check = env.Command(f'{output}/scons.log',
                       None,
                       f'{revpath} -h > $TARGET')

# aggregators perform analysis on a nest
# this one will collect the mutual information matrices
nest.add_aggregate('mi_agg', list)

# nests define parameter sweeps
nest.add('d', (1, 10))
nest.add('n_iid', range(10, 110, 10))
n_epi_range = np.array(range(10, 110, 10))
if any(n_epi_range % 2 != 0):
    raise ValueError('n_epi must be even!')
nest.add('n_epi', n_epi_range)
nest.add('replicate', range(1, replicates + 1))


@nest.add_target()
def alns(outdir, c):
    '''iid and epistatic alignments'''
    alns = env.Command([f'{outdir}/iid_aln.nex',
                        f'{outdir}/epi_aln.nex'],
                       None,
                       'Rscript simulation_scripts/mk_alns.R '
                       f'{c["n_iid"]} {c["n_epi"]} {c["d"]} {c["replicate"]} '
                       f'{outdir} {revpath} &> {outdir}/mk_alns.log')
    env.Depends(alns, rb_check)
    return alns


@nest.add_target()
def aln(outdir, c):
    '''concatentate the iid and epistatic alignments into one'''
    return env.Command(f'{outdir}/aln.nex',
                       c['alns'],
                       'Rscript simulation_scripts/merge_alns.R '
                       '$SOURCES $TARGET '
                       f' &> {outdir}/merge_alns.log')


@nest.add_target()
def mi(outdir, c):
    '''column mutual information matrix summary stats'''
    mi = env.Command(f'{outdir}/aln.nex.mi.summary.txt',
                     [c['aln'], c['d'], c['n_iid'], c['n_epi']],
                     'python indices/align_mi.py $SOURCES[0]')
    c['mi_agg'].append(mi)
    return mi


# pop to the top level to aggregate
nest.pop('d')


@nest.add_target()
def mi_agg(outdir, c):
    '''aggregate mutual infomation matrices'''
    return env.Command(f'{outdir}/mi_agg.skewness.pdf',
                       c['mi_agg'],
                       f'python utils/mi_agg.py {outdir}')
